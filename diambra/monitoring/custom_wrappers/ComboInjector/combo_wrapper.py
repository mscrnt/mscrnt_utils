"""
combo_wrapper.py

A Gymnasium wrapper that uses ComboInjector to modify the actions passed to the environment.
It replaces the agent’s action with a combo action generated by the injector if injection is active,
and otherwise falls back to the agent's original action.
"""

import gymnasium as gym
from collections import deque
import numpy as np

# Import your ComboInjector from the package.
from .combo_injector import ComboInjector

class ComboWrapper(gym.Wrapper):
    def __init__(self, env, characters, super_arts, injector_kwargs=None):
        """
        Initialize the ComboWrapper.

        Parameters
        ----------
        env : gym.Env
            The original Gymnasium environment to wrap.
        characters : list of str
            List of character names (e.g. ['Alex', 'Ken']) for each agent.
        super_arts : list of int
            List of super art indices (e.g. [1, 3]) for each agent.
        injector_kwargs : dict, optional
            Additional keyword arguments for ComboInjector (e.g., {"environment_name": "sfiii3n", "frame_skip": 4, "mode": "multi_discrete"}).
        """
        super().__init__(env)
        if injector_kwargs is None:
            injector_kwargs = {}
        self.injector = ComboInjector(**injector_kwargs)
        self.injector.reset(characters, super_arts)
        # Optionally adjust the underlying environment’s action space here if needed.

    def step(self, action):
        """
        Override the step() function to inject combo actions if injection is active.
        
        The passed action is replaced with an injected combo action when the injection probability hasn't decayed.
        Once the injection decays, the agent's original action is used.

        Returns
        -------
        obs, reward, terminated, truncated, info : tuple
            The observation, reward, termination flag, truncation flag, and info dictionary.
        """
        # Try to get an injected action.
        injected = self.injector.sample()
        if injected is not None:
            modified_action = injected['multi_discrete']
            if isinstance(modified_action, dict):
                # For multi-agent environments, extract the single-agent action.
                modified_action = list(modified_action.values())[0]
        else:
            # Injection has decayed; use the original action.
            modified_action = action

        # Call the underlying env's step method.
        step_result = self.env.step(modified_action)

        # Unpack the step result depending on the API.
        if len(step_result) == 4:
            obs, reward, done, info = step_result
            terminated = done
            truncated = False
        else:
            obs, reward, terminated, truncated, info = step_result

        return obs, reward, terminated, truncated, info

    def reset(self, **kwargs):
        """
        Reset the environment and clear the injector's move queues.

        Returns
        -------
        obs : object
            The initial observation.
        """
        for agent in self.injector.agent_state:
            self.injector.agent_state[agent]['move_sequence'] = deque()
        obs = self.env.reset(**kwargs)
        return obs
